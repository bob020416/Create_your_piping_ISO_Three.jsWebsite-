<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js WebGL - Build Your ISO Graphics Quickly</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #f0f0f0;
            color: #444;
            font-family: Arial, sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        a {
            color: #08f;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 15px;
            background-color: #eee;
            border-radius: 5px;
            width: 120px; /* set the width to your desired value */
            font-size: 14px; /* set the font size to your desired value */
            text-align: center; /* center the text */
            line-height: 1.5; /* increase the line height for better readability */
        }

        #scene {
            width: calc(100% - 150px);
            height: 100vh;
        }
        #controls {
            position: absolute;
            right: 0;
            top: 0;
            width: 150px;
            height: 100vh;
            background-color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
        }
        button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            background-color: #08f;
            color: #fff;
            cursor: pointer;
            margin-bottom: 10px;
        }
    </style>
    
</head>
<body>
    <div id="scene"></div>
    <div id="controls">
        <div id="info">
            <p><a href="https://threejs.org" target="_blank" rel="noopener">Three.js</a></p>
            <p>高速建置您的ISO圖資</p>
            <p>按住 "Shift+左鍵" 移動物件</p>
        </div>
        
        <button id="addXLine">添加X軸線</button>
        <button id="addYLine">添加Y軸線</button>
        <button id="addZLine">添加Z軸線</button>
        <button id="deleteLine">刪除所選物件</button>
        <button id="addRectangle">添加閥件</button>
        <button id="addArrow">添加Reducer</button>
    </div>
    
    


		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { DragControls } from 'three/addons/controls/DragControls.js';
            import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';


			let container;
            let camera, scene, renderer;
            let controls, group;
            let enableSelection = false;
            let orbitControls;  // Rename the variable
            
            


            let objects = [];  // Change const to let here
            let selectedObject = null;

            const mouse = new THREE.Vector2(), raycaster = new THREE.Raycaster();
            const material = new THREE.LineBasicMaterial({ color: 0x0000ff }); 

			init();

			function init() {

				container = document.getElementById('scene');

				camera = new THREE.PerspectiveCamera( 70, container.clientWidth / container.clientHeight, 0.1, 500 );
				camera.position.z = 25;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				scene.add( new THREE.AmbientLight( 0xaaaaaa ) );

				const light = new THREE.SpotLight( 0xffffff, 10000 );
				light.position.set( 0, 25, 50 );
				light.angle = Math.PI / 9;

				light.castShadow = true;
				light.shadow.camera.near = 10;
				light.shadow.camera.far = 100;
				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;

				scene.add( light );
                
                
                // Add grid helper
                const size = 100;
                const divisions = 100;
                const gridHelper = new THREE.GridHelper(size, divisions);
                gridHelper.rotation.x = Math.PI / 2; // Rotate grid to XZ plane
                gridHelper.translateZ(-10); // Move the grid 10 units towards negative Z
                scene.add(gridHelper);  // Add the grid to the scene

                // Create a material with the desired transparency
                const lineMaterial = new THREE.LineBasicMaterial({ transparent: true, opacity: 0.5 });

                // Iterate over the lines in the GridHelper and update their material
                gridHelper.traverse(child => {
                if (child instanceof THREE.Line) {
                    child.material = lineMaterial;
                }
                });

                scene.add(gridHelper);  // Add the grid to the scene


				group = new THREE.Group();
				scene.add( group );

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( container.clientWidth, container.clientHeight );
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFShadowMap;




                container.appendChild( renderer.domElement );

                // Set up the OrbitControls
                orbitControls = new OrbitControls(camera, renderer.domElement);
                orbitControls.enableRotate = false;  // Disable rotation

                orbitControls.screenSpacePanning = true;  // Enable 2D panning


                
                controls = new DragControls( [ ... objects ], camera, renderer.domElement );
                controls.addEventListener( 'drag', render );

				//

				window.addEventListener( 'resize', onWindowResize );

				document.addEventListener( 'click', onClick );
				window.addEventListener( 'keydown', onKeyDown );
				window.addEventListener( 'keyup', onKeyUp );

				render();

			}

			document.getElementById('addXLine').addEventListener('click', function() {
				const xPoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(10, 10, 0)];
				const xGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
				const xLine = new THREE.Line(xGeometry, material);
				scene.add(xLine);
				objects.push(xLine);
				render();
			});

			document.getElementById('addYLine').addEventListener('click', function() {
				const yPoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(-10, 10, 0)];
				const yGeometry = new THREE.BufferGeometry().setFromPoints(yPoints);
				const yLine = new THREE.Line(yGeometry, material);
				scene.add(yLine);
				objects.push(yLine);
				render();
			});

			document.getElementById('addZLine').addEventListener('click', function() {
				const zPoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 10, 0)];
				const zGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
				const zLine = new THREE.Line(zGeometry, material);
				scene.add(zLine);
				objects.push(zLine);
				render();
			});

			document.getElementById('deleteLine').addEventListener('click', function() {
                if (selectedObject) {
                    scene.remove(selectedObject);
                    objects = objects.filter(obj => obj !== selectedObject);
                    selectedObject = null;
                    updateControls();
                    render();
                }
            });


            document.getElementById('addRectangle').addEventListener('click', addRectangle);
            document.getElementById('addArrow').addEventListener('click', addArrow);

            function addRectangle() {
                const rectShape = new THREE.Shape();
                rectShape.moveTo(0, 0);
                rectShape.lineTo(0, 10);
                rectShape.lineTo(-2.5, 10);
                rectShape.lineTo(-2.5, 0);
                rectShape.lineTo(0, 0);

                const rectGeom = new THREE.BufferGeometry().setFromPoints(rectShape.getPoints());
                const rectLine = new THREE.LineLoop(rectGeom, material);
                scene.add(rectLine);
                objects.push(rectLine);
                updateControls();
                render();
            }


            function addArrow() {
                const arrow = new THREE.Shape();
                arrow.moveTo(0, 0);
                arrow.lineTo(2.5,0 );
                arrow.lineTo(1.25, -2.5);
                arrow.lineTo(0, 0);
                const arrowGeom = new THREE.BufferGeometry().setFromPoints(arrow.getPoints());
                const arrowLine = new THREE.LineLoop(arrowGeom, material);
                scene.add(arrowLine);
                objects.push(arrowLine);
                updateControls();
                render();
            }

        


			function onWindowResize() {

				camera.aspect = container.clientWidth / container.clientHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( container.clientWidth, container.clientHeight );

				render();

			}

			function onKeyDown( event ) {

				enableSelection = ( event.keyCode === 16 ) ? true : false;

			}

			function onKeyUp() {

				enableSelection = false;

			}

			function onClick( event ) {
                event.preventDefault();

                mouse.x = ( event.clientX / container.clientWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / container.clientHeight ) * 2 + 1;

                raycaster.setFromCamera( mouse, camera );

                const intersections = raycaster.intersectObjects( objects, true );

                if ( intersections.length > 0 ) {
                    let closestObject = intersections[0].object;
                    let closestDistance = intersections[0].distance;
                    for (let i = 1; i < intersections.length; i++) {
                        if (intersections[i].distance < closestDistance) {
                            closestDistance = intersections[i].distance;
                            closestObject = intersections[i].object;
                        }
                    }
                    selectedObject = closestObject;
                }

                if ( enableSelection === true ) {
                    const draggableObjects = controls.getObjects();
                    draggableObjects.length = 0;

                    if ( intersections.length > 0 ) {
                        const object = intersections[0].object;

                        if (object.material && object.material.emissive) {
                            if ( group.children.includes( object ) ) {
                                object.material.emissive.set( 0x000000 );
                                scene.attach( object );
                            } else {
                                object.material.emissive.set( 0xaaaaaa );
                                group.attach( object );
                            }
                        }

                        controls.transformGroup = true;
                        draggableObjects.push( group );
                    }

                    if ( group.children.length === 0 ) {
                        controls.transformGroup = false;
                        draggableObjects.push( ...objects );
                    }
                }

                render();
            }

            function updateControls() {
                // If controls already exists, remove its event listener
                if (controls) {
                    controls.removeEventListener('drag', render);
                }

                // Create new controls with updated objects
                controls = new DragControls(objects, camera, renderer.domElement);
                controls.addEventListener('drag', render);
            }




			function render() {
                orbitControls.update();  // Update the orbit controls before rendering
                renderer.render( scene, camera );
            }


		</script>

	</body>
</html>
